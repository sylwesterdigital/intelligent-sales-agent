import os
from datetime import datetime

from dotenv import load_dotenv
from flask import Flask, render_template, request, redirect, url_for, flash
from flask_sqlalchemy import SQLAlchemy

# Load environment variables from .env
load_dotenv()

# Flask application configuration and database setup
app = Flask(__name__)
app.secret_key = os.getenv("SECRET_KEY", "change-this-secret-key")

DB_NAME = os.getenv("DB_NAME", "appdb")
DB_USER = os.getenv("DB_USER", "appuser")
DB_PASSWORD = os.getenv("DB_PASSWORD", "apppassword")
DB_HOST = os.getenv("DB_HOST", "localhost")
DB_PORT = os.getenv("DB_PORT", "5432")

app.config["SQLALCHEMY_DATABASE_URI"] = (
    f"postgresql+psycopg2://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
)
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

db = SQLAlchemy(app)


class Lead(db.Model):
    """Database model for a single lead generated by the AI Sales Machine."""
    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # ICP snapshot
    icp_job_title = db.Column(db.String(128))
    icp_company_type = db.Column(db.String(128))
    icp_location = db.Column(db.String(128))
    icp_industry = db.Column(db.String(128))
    icp_size_min = db.Column(db.Integer)
    icp_size_max = db.Column(db.Integer)
    icp_value_proposition = db.Column(db.Text)

    # Lead data
    lead_name = db.Column(db.String(256))
    lead_title = db.Column(db.String(128))
    company_name = db.Column(db.String(256))
    company_website = db.Column(db.String(512))
    location = db.Column(db.String(128))
    work_email = db.Column(db.String(256))

    # Qualification and status
    score = db.Column(db.Float)
    status = db.Column(db.String(64))  # e.g., SOURCED, MESSAGED, REPLIED

    # Channels
    linkedin_url = db.Column(db.String(512))
    channel_email_enabled = db.Column(db.Boolean, default=True)
    channel_linkedin_enabled = db.Column(db.Boolean, default=True)

    # Generated outbound content
    first_touch_email = db.Column(db.Text)
    followup_email = db.Column(db.Text)
    first_touch_linkedin = db.Column(db.Text)
    followup_linkedin = db.Column(db.Text)


def scrape_and_enrich(icp):
    """Simulates scraping and enrichment by generating example leads based on the ICP."""
    sample_companies = [
        ("PixelGrowth Agency", "pixelgrowthagency.com"),
        ("NYC Performance Media", "nycperformancemedia.com"),
        ("Brooklyn Digital Studio", "brooklyndigitalstudio.com"),
        ("Manhattan Funnels Co.", "manhattanfunnels.co"),
        ("Queens Creative Labs", "queenscreativelabs.com"),
    ]
    leads = []
    for idx, (company, domain) in enumerate(sample_companies, start=1):
        lead = {
            "lead_name": f"Founder{idx} Example",
            "lead_title": icp["job_title"],
            "company_name": company,
            "company_website": f"https://{domain}",
            "location": icp["location"],
            "work_email": f"founder{idx}.example@{domain}",
            "linkedin_url": f"https://www.linkedin.com/in/founder{idx}example",
        }
        leads.append(lead)
    return leads


def qualify_leads(leads, icp):
    """Assigns a simple qualification score from 0–10 based on ICP keyword and location matches."""
    qualified = []
    for lead in leads:
        score = 10.0

        if icp["industry"].lower() not in icp["company_type"].lower():
            score -= 1.0

        if icp["location"].lower() not in lead["location"].lower():
            score -= 2.0

        score = max(0.0, min(10.0, score))
        lead["score"] = score
        qualified.append(lead)
    return qualified


def generate_sequences(lead, icp):
    """Generates simple personalized email and LinkedIn sequences for a lead."""
    vp = icp["value_proposition"]
    company = lead["company_name"]
    name = lead["lead_name"]

    first_email = (
        f"Subject: {company} ✕ AI-powered outbound\n\n"
        f"Hi {name.split()[0]},\n\n"
        f"Working with agencies like {company}, outbound works but it is hard to keep it consistent. "
        f"This AI Sales Engine scrapes, enriches, qualifies and messages your ICP on autopilot "
        f"so the team can focus on conversations instead of manual prospecting.\n\n"
        f"{vp}\n\n"
        f"Open to a quick 15-minute walkthrough?\n"
    )

    follow_email = (
        f"Subject: Quick follow-up, {name.split()[0]}\n\n"
        f"Just bumping this in case it slipped through. "
        f"A short breakdown video of the system is ready if that is easier to review.\n"
    )

    first_li = (
        f"Hey {name.split()[0]}, saw you run {company}. "
        f"Built an AI-powered outbound engine for agencies that finds and messages "
        f"the exact ICP on autopilot. Open to connect?"
    )

    follow_li = (
        f"Appreciate the connect, {name.split()[0]} — "
        f"happy to send the short breakdown video of the engine if there is interest."
    )

    lead["first_touch_email"] = first_email
    lead["followup_email"] = follow_email
    lead["first_touch_linkedin"] = first_li
    lead["followup_linkedin"] = follow_li

    return lead


def run_pipeline(icp):
    """Runs the full pipeline from scraping to storing generated leads."""
    raw_leads = scrape_and_enrich(icp)
    scored_leads = qualify_leads(raw_leads, icp)

    db_leads = []
    for lead in scored_leads:
        lead = generate_sequences(lead, icp)
        db_lead = Lead(
            icp_job_title=icp["job_title"],
            icp_company_type=icp["company_type"],
            icp_location=icp["location"],
            icp_industry=icp["industry"],
            icp_size_min=icp["size_min"],
            icp_size_max=icp["size_max"],
            icp_value_proposition=icp["value_proposition"],
            lead_name=lead["lead_name"],
            lead_title=lead["lead_title"],
            company_name=lead["company_name"],
            company_website=lead["company_website"],
            location=lead["location"],
            work_email=lead["work_email"],
            linkedin_url=lead["linkedin_url"],
            score=lead["score"],
            status="MESSAGED",
            channel_email_enabled=True,
            channel_linkedin_enabled=True,
            first_touch_email=lead["first_touch_email"],
            followup_email=lead["followup_email"],
            first_touch_linkedin=lead["first_touch_linkedin"],
            followup_linkedin=lead["followup_linkedin"],
        )
        db_leads.append(db_lead)

    for l in db_leads:
        db.session.add(l)
    db.session.commit()
    return db_leads


@app.route("/", methods=["GET", "POST"])
def index():
    """Renders the main dashboard, handles ICP submissions, and lists latest leads."""
    if request.method == "POST":
        icp = {
            "job_title": request.form.get("job_title", "CEO"),
            "company_type": request.form.get("company_type", "Digital Marketing Agency"),
            "location": request.form.get("location", "New York"),
            "size_min": int(request.form.get("size_min", 1)),
            "size_max": int(request.form.get("size_max", 50)),
            "industry": request.form.get("industry", "Marketing"),
            "value_proposition": request.form.get(
                "value_proposition",
                "We build AI-powered outbound machines that create a consistent flow of qualified demos for agencies.",
            ),
        }

        leads = run_pipeline(icp)
        flash(f"Pipeline completed. {len(leads)} leads sourced and processed.", "success")
        return redirect(url_for("index"))

    latest_leads = Lead.query.order_by(Lead.created_at.desc()).limit(50).all()
    return render_template("index.html", leads=latest_leads)


@app.route("/api/leads")
def api_leads():
    """Returns the latest leads as JSON for front-end or API usage."""
    latest_leads = Lead.query.order_by(Lead.created_at.desc()).limit(100).all()
    payload = []
    for lead in latest_leads:
        payload.append(
            {
                "id": lead.id,
                "lead_name": lead.lead_name,
                "lead_title": lead.lead_title,
                "company_name": lead.company_name,
                "location": lead.location,
                "work_email": lead.work_email,
                "linkedin_url": lead.linkedin_url,
                "score": lead.score,
                "status": lead.status,
            }
        )
    return {"leads": payload}


if __name__ == "__main__":
    # Ensure tables exist before serving requests (Flask 3 compatible)
    with app.app_context():
        db.create_all()
    app.run(host="0.0.0.0", port=5050, debug=True)
